(* Exercises A *)
(* A.0 *)
let rec range m n =
  if m > n then []
  else m :: range (m + 1) n

let irange m n =
  let rec iter i lst =
    if i < m then lst
    else iter (i - 1) (i :: lst)
  in
  iter n []

(* A.1 *)
let rec last_sublist = function
  | [] -> invalid_arg "last_sublist: empty list"
  | [i] -> [i]
  | _ :: t -> last_sublist t

(* A.2 *)
let reverse lst =
  let rec iter rev out = 
    match rev with
    | [] -> out
    | h :: t -> iter t (h :: out)
  in iter lst []

(* A.3 *)
let rec square_list = function
  | [] -> []
  | h :: t -> (h * h) :: (square_list t)
let square_list2 items = List.map (fun n -> n * n) items

(* A.4 *)
(* his solution doesn't work because it reverses the list
It does this by adding the first element on the list to the start of the answer list.
Since we add elements to the start of the list one by one, the first element
of the original list will end up being the last element of the reversed list (but squared of course),
and thus we are left with a reversed list of squared elements

the second solution doesn't work where we have an expected type for this operator ::
where the second argument cannot be an integer (the order needs to be reversed as in the first solution)
So we have an error because the types are incorrect for the operator (int list :: int doesn't work)

We can fix this easily with:
*)
(* let square_list items =
  let rec iter things answer =
    match things with
      | [] -> answer
      | h :: t -> iter t (answer @ [h * h])
  in iter items [] *)

(* This new function is not efficient because the append list operator
takes time O(n) and you call it for each element in the original items list
so the total time complexity is O(n^2) *)

(* A.5 *)
let rec count_negative_numbers = function
  | [] -> 0
  | h :: t -> (if h < 0 then 1 else 0) + count_negative_numbers t

(* A.6 *)
let power_of_two_list n =
  let rec pow base exp =
    match exp with
      | 0 -> 1
      | 1 -> base
      | _ -> base * pow base (exp - 1)
  in
  let rec iter i =
    match i with
      | i when i = n -> []
      | _ -> (pow 2 i) :: iter (i + 1)
  in iter 0

(* A.7 *)
let prefix_sum lst = 
  let rec iter out sum =
    match out with
      | [] -> []
      | h :: t -> (h + sum) :: (iter t (h + sum))
  in iter lst 0

(* A.8 *)
let deep_reverse lst = 
  let rec iter lst2 out =
    match lst2 with
      | [] -> out
      | h :: t -> iter t ((reverse h) :: out)
  in iter lst []

(* A.9 *)
type 'a nested_list =
  | Value of 'a
  | List of 'a nested_list list

let rec deep_reverse_nested lst =
  let rec iter lst out =
    match lst with
      | [] -> out
      | Value h :: t -> iter t ((Value h) :: out)
      | List h :: t -> iter t (deep_reverse_nested (List h) :: out)
  in
  match lst with
    | Value h -> Value h
    | List h -> List (iter h [])


(* Exercises B *)
(* B.1 *)
let rec quicksort cmp lst =
  match lst with
  | [] -> []
  | pivot :: t ->
      let smaller = List.filter (fun x -> cmp x pivot) t in
      let larger = List.filter (fun x -> not (cmp x pivot)) t in
      (quicksort cmp smaller) @ [pivot] @ (quicksort cmp larger)

(* B.2 *)
(*
This is a generative recursive function because the functions we 
are recursing over are generated by the function itself. In other words,
we generate new lists which are not the original input list and recurse over 
the generated ones. We then combine these newly generated lists into a 
sorted output.
*)

(* B.3 *)
(* Ben's code does not consider the basecase of length 1. This means that when 
the list is split into odd and even halves, there will be 1 of length 1 and one of length 0.
the length 1 list is recursed on again and attempted to split, but it cannot because there is no 
base case for length 1 list. So the recursion results in an infinite loop 
(whenever the recursion reaches a list of length 1 this occurs)
*)

(* B.4 *)
let rec insert_in_order cmp new_result a_list =
  match a_list with
    | [] -> [new_result]
    | h :: _ when cmp new_result h -> new_result :: a_list
    | h :: t ->  h :: insert_in_order cmp new_result t

let rec insertion_sort cmp a_list =
  match a_list with
    | [] -> []
    | h :: t -> insert_in_order cmp h (insertion_sort cmp t)

(* This is an example of structural recursion because we are recursing on 
the list itself (through the tail) and combining it with the head in some way.
We are not generating any new lists.
*)

(* Exercises C *)
(* C.1 *)
let rec subsets = function
  | [] -> [[]]
  | h :: t -> let rest = subsets t in
      rest @ (List.map (fun x -> h :: x) rest)

(* 
We can create all subsets of the list by recursively either adding the first element
to the subset or omitting the first element from the subset. The function does that by seperating
the head, then recursing on the remaining elements of the input list and findind the subsets of the remaining
before appending them all together to get the full list of subsets.
*)

(* C.2 *)
let rec accumulate op initial sequence =
  match sequence with
    | [] -> initial
    | h :: t -> op h (accumulate op initial t)

let map p sequence =
  accumulate (fun x r -> (p x) :: r) [] sequence

let append seq1 seq2 =
  accumulate (fun x r -> x :: r) seq2 seq1

let length sequence =
  accumulate (fun _ x -> x + 1) 0 sequence

(* C.3 *)
let rec accumulate_n op init seqs =
  match seqs with
    | [] -> failwith "empty list"
    | [] :: _ -> []   (* assume all sublists are empty *)
    | _ ->  (* non-empty list containing non-empty sublists *)
        accumulate op init (List.map List.hd seqs) :: accumulate_n op init (map List.tl seqs)


(* C.4 *)

let rec map2 f x y =
  match (x, y) with
    | ([], []) -> []
    | ([], _) -> failwith "unequal lists"
    | (_, []) -> failwith "unequal lists"
    | (h1 :: t1, h2 :: t2) -> (f h1 h2) :: (map2 f t1 t2)

let dot_product v w = accumulate (+) 0 (map2 ( * ) v w)

let matrix_times_vector m v = map (fun x -> dot_product x v) m

let transpose mat = accumulate_n (fun x y -> x :: y) [] mat

let matrix_times_matrix m n =
  let cols = transpose n in
     map (fun x -> matrix_times_vector cols x) m