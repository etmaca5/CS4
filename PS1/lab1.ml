(* Part A: exercises *)
(* Recursive function to calculate the sum of squares from 0 to n *)

(* A.0 *)
let rec sum_squares_to n =
    if n = 0 then 0
    else n * n + sum_squares_to (n - 1)

(* A.1
1. int = 10  
2. float = 10.  
3. int = 12  
4. Error: The constant 3.2 has type float but an expression was expected of type
         int 
Error occured because the `+` operator is not defined for the type float, should be +. instead 
5.Error: The constant 3 has type int but an expression was expected of type float
  Hint: Did you mean 3.? 
Error occured because the `+.` operator is not defined for the type int, should be + instead 
6. Error: The constant 4.2 has type float but an expression was expected of type
         int
Error occured because an int is expected when seeing the operand +, so the 4.2 causes an error
7.Error: The constant 3 has type int but an expression was expected of type float
  Hint: Did you mean 3.? 
Error occured because you cannot add an int with the '+.' operand it expects a float not 3
8. float = 7.2  
9. int = 5  
10. int = 7  
11. val a : int = 3  
12. val b : int = 4  
13. bool = false  
14. bool = true  
15. bool = false - This is different from the previous expression because == checks that they are in the same place in memory instead of = which just checks for the same values
16. (int * int * int) list = [(1, 2, 3)]
17. (int * int * int) list = [(1, 2, 3)] This occurs because [1, 2, 3]` is interpreted as a list of integers split by commas which forms a tuple (1, 2, 3) and then wrapped in a list, and then placed in a list. Unfortunately, equivalent to the previous expression
18. int = 4
19. Error: Syntax error
Syntax error occurs because and doesn't exist in Ocaml, should be replaced with && instead
20. int = 6
21. int = 4 - this is different from the previous case because the previous case adds b to the result of the if else whereas this case only adds 2 if we reach the else (so a >= b)
22. int = 6
23. Error: The value b has type int but an expression was expected of type 
       unit because it is in the result of a conditional with no else branch
Here we get a type error because there is no else branch. Whenever we have an if branch ocaml expects and else condition aswell
*)

(* A.2 *)
let sum_of_squares_of_two_largest x y z =
    if x <= y && x <= z then y * y + z * z
    else if y <= x && y <= z then x * x + z * z
    else x * x + y * y

(* A.3 *)
(* This function adds a to the absolute values of b. If b is 
greater that 0 plus and if it is negative then we negate it to 
a positive value *)

(* Part B exercises *)
(* B.1 *)
(* 
When Ben uses the applicative order evaluation all arguments of a function are evaluated first, so since p() is recursively defined
to call itself, when we evaluate p() it will call itself infinitely and never return a value. Thus, the program infinite loops and
crashes. For the normal order evaluation, the arguments are only evaluated when they are needed, so x = 0 will be evaluated first,
and this the recursive p() will never be called. So the program will return 0 for a normal order evaluation.
*)

(* B.2 *)
(* When the function is called all of the arguments are evaluated first. Since the then else clause contains sqrt_iter it will be
evaluated immediately, but in that recursive call it is called again without returning, so it will enter anther recursive call, and so on.
The recursion will continue infinitely until the stack overflows. *)

(* B.3 *)

(* 
1. The process generated by add_a is recursive. The process generated by add_b is iterative.
*)

(* 
2.
Evaluate add_a 2 5
    2 -> 2
    5 -> 5
    desugar add_a to:
        fun a b -> if a = 0 then b else inc (add_a (dec a) b)
    apply fun a b -> (...) to 2, 5
        substitute 2 for a, 5 for b in if a = 0 then b else inc (add_a (dec a) b)
            -> if 2 = 0 then 5 else inc (add_a (dec 2) 5)
        evaluate if 2 = 0 then 5 else inc (add_a (dec 2) 5)
            if is a special form, so evaluate the first operand:
            evaluate 2 = 0
                2 -> 2
                0 -> 0
                = -> =
                apply = to 2, 0 -> false
            first argument of if is false, so evaluate the third operand:
                evaluate inc (add_a (dec 2) 5)
                    apply inc to add_a (dec 2) 5
                        evalute add_a (dec 2) 5
                            desugar add_a to:
                                fun a b -> if a = 0 then b else inc (add_a (dec a) b)
                            apply fun a b -> (...) to (dec 2) 5
                                evaluate dec 2
                                    2 -> 2
                                    dec -> dec
                                    apply dec to 2 -> 1
                                evalute add_a 1 5
                                    1 -> 1
                                    5 -> 5
                                    desugar add_a to:
                                        fun a b -> if a = 0 then b else inc (add_a (dec a) b)
                                    apply fun a b -> (...) to 1 5
                                        substitute 1 for a, 5 for b in if a = 0 then b else inc (add_a (dec a) b)
                                            -> if 1 = 0 then 5 else inc (add_a (dec 1) 5)
                                        evaluate if 1 = 0 then 5 else inc (add_a (dec 1) 5)
                                            if is a special form, so evaluate the first operand:
                                                evaluate 1 = 0
                                                    1 -> 1
                                                    0 -> 0
                                                    = -> =
                                                    apply = to 1, 0 -> false
                                            first argument of if is false, so evaluate the third operand:
                                                evaluate inc (add_a (dec 1) 5)
                                                    desugar evaluate inc (...) to:
                                                        fun a -> a + 1
                                                    apply fun a -> a + 1 to add_a (dec 1) 5
                                                        evalute add_a (dec 1) 5
                                                            desugar add_a to:
                                                                fun a b -> if a = 0 then b else inc (add_a (dec a) b)
                                                            apply fun a b -> (...) to (dec 1) 5
                                                                evaluate dec 1
                                                                    1 -> 1
                                                                    dec -> dec
                                                                    apply dec to 1 -> 0
                                                                evalute add_a 0 5
                                                                    0 -> 0
                                                                    5 -> 5
                                                                    desugar add_a to:
                                                                        fun a b -> if a = 0 then b else inc (add_a (dec a) b)
                                                                    apply fun a b -> (...) to 0 5
                                                                        substitute 0 for a, 5 for b in if a = 0 then b else inc (add_a (dec a) b)
                                                                            -> if 0 = 0 then 5 else inc (add_a (dec 0) 5)
                                                                        evaluate if 0 = 0 then 5 else inc (add_a (dec 0) 5)
                                                                            if is a special form, so evaluate the first operand:
                                                                                evaluate 0 = 0
                                                                                    0 -> 0
                                                                                    0 -> 0
                                                                                    = -> =
                                                                                    apply = to 0, 0 -> true
                                                                            first argument of if is true, so evaluate the second operand:
                                                                                5 -> 5
                                                                    result: 5
                                                                result: 5
                                                            result: 5
                                                        apply (fun a -> a + 1) to 5
                                                            5 -> 5
                                                            inc -> inc
                                                            apply inc to 5 -> 6
                                                    result: 6
                                                result: 6
                                            result: 6
                                        result: 6
                                    result: 6
                                result: 6
                            result: 6
                        result: 6
                    apply inc to 6
                        6 -> 6
                        inc -> inc
                        apply inc to 6 -> 7
                result: 7
            result: 7
        result: 7
    result: 7
add_a 2 5 evaluates to 7
*)

(*
3.

let rec add_b a b =
  if a = 0
     then b
     else add_b (dec a) (inc b)

Desugar this to:

let rec add_b =
  fun a b ->
    if a = 0
       then b
       else add_b (dec a) (inc b)

Bind the name "add_b" to the value:

  fun a b ->
    if a = 0
       then b
       else add_b (dec a) (inc b)

Evaluate (add_b 2 5)
  >>> 2 -> 2 
  >>> 5 -> 5 
  apply (fun a b -> if ...) to 2, 5
  substitute 2 for a, 5 for b in (if ...)
    -> if 2 = 0 then 5 else add_b (dec 2) (inc 5)
  evaluate (if 2 = 0 then 5 else add_b (dec 2) (inc 5))
    if is a special form, so evaluate the first operand:
      evaluate (2 = 0)
        >>> 2 -> 2 
        >>> 5 -> 0 
        >>> = -> =
        apply = to 2, 0 -> false
    first argument of if is false, so evaluate the third operand:
      evaluate (add_b (dec 2) (inc 5))
        evaluate (dec 2)
          >>> 2 -> 2 
          >>> dec -> dec
          apply dec to 2 -> 1
        evaluate (inc 5)
          >>> 5 -> 5
          >>> inc -> inc
          apply inc to 5 -> 6
        apply (fun a b -> if ...) to 1, 6
        substitute 1 for a, 6 for b in (if ...)
          -> if 1 = 0 then 6 else add_b (dec 1) (inc 6)
        evaluate (if 1 = 0 then 6 else add_b (dec 1) (inc 6))
          if is a special form, so evaluate the first operand:
            evaluate (1 = 0)
                >>> 1 -> 1
                >>> 0 -> 0
                >>> = -> =
              apply = to 1, 0 -> false
          first argument of if is false, so evaluate the third operand:
            evaluate (add_b (dec 1) (inc 6))
              evaluate (dec 1)
                >>> 1 -> 1
                >>> dec -> dec
                apply dec to 1 -> 0
              evaluate (inc 6)
                >>> 6 -> 6
                >>> inc -> inc
                apply inc to 6 -> 7
              apply (fun a b -> if ...) to 0, 7
              substitute 0 for a, 7 for b in (if ...)
                -> if 0 = 0 then 7 else add_b (dec 0) (inc 7)
              evaluate (if 0 = 0 then 7 else add_b (dec 0) (inc 7))
                if is a special form, so evaluate the first operand:
                  evaluate (0 = 0)
                    >>> 0 -> 0
                    >>> 0 -> 0
                    >>> = -> =
                    apply = to 0, 0 -> true
                first argument of if is true, so evaluate the second operand:
                    7-> 7
                result: 7
            result: 7
        result: 7
    result: 7
result: 7
*)


(* Part C exercises *)
(* C.1 *)

let rec factorial n =
    if n = 0 then 1 else n * factorial (n - 1)

(* a *)
let e_term n =
    1.0 /. float_of_int (factorial n)

(* b *)
let rec e_approximation n =
    if n = 0 then e_term 0
    else e_term n +. e_approximation (n - 1)

(* c *)
let approximate_e = e_approximation 20
let actual_e = exp 1.0
(* 
exp 1.0;;
- : float = 2.71828182845904509
e_approximation 20;;
- : float = 2.71828182845904553
They are very close together

*)

(* d *)
(* If you try summming the 100th term of the infite series expansion you get that the approximation is infinity.
This occurs because the factorial values grow extremely large and the value becomes bigger than the maximum integer size,
so it wraps around and reaches near 0. As a result the e_term will evaluate to infinity
*)

(* C.2 *)
let rec is_even n =
    if n = 0 then true
    else is_odd (n - 1)
and is_odd n =
    if n = 0 then false
    else is_even (n - 1)


(* C.3 *)
let rec f_rec n =
    if n < 3 then n
    else f_rec (n - 1) + 2 * f_rec (n - 2) + 3 * f_rec (n - 3)

let f_iter n =
    let rec helper n a b c =
        if n < 3 then a
        else helper (n - 1) (a + 2 * b + 3 * c) a b
    in
    if n < 3 then n
    else helper n 2 1 0

(* C.4 *)
let rec pascal_coefficient row idx =
    match (row, idx) with
    | (row, idx) when row < 1 || idx < 1 || idx > row -> failwith "invalid arguments"
    | (_, 1) -> 1
    | (row, idx) when idx = row -> 1
    | (row, idx) -> pascal_coefficient (row - 1) (idx - 1) + pascal_coefficient (row - 1) idx
